package org.firstinspires.ftc.teamcode;

//import com.disnodeteam.dogecv.CameraViewDisplay;
//import com.disnodeteam.dogecv.DogeCV;
//import com.disnodeteam.dogecv.detectors.roverrukus.SamplingOrderDetector;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.Range;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.DcMotorEx;

import org.firstinspires.ftc.teamcode.Robot;
//import com.disnodeteam.dogecv.detectors.roverrukus.GoldAlignDetector;


/**
 * Created by femukund on 10/29/2017.
 */

@TeleOp
public class AviatorBotDrive extends LinearOpMode {
    Robot robot = new Robot();
    private DcMotor leftFrontDrive = null;
    private DcMotor rightFrontDrive = null;
    private DcMotor leftBackDrive = null;
    private DcMotor rightBackDrive = null;
    private Servo wobblerServo = null;
    private DcMotor armMotor = null;
    private DcMotorEx launchMotor = null;
    private DcMotor intakeMotor = null;
    private Servo launchServo = null;
    //GoldAlignDetector goldDetector;
    //SamplingOrderDetector detector;

    double[] p = {1, 1, 1, 1};
    //leftfront = 0
    //rightfront = 1
    //leftback = 2
    //rightback = 3

    @Override
    public void runOpMode() throws InterruptedException {
        robot.init(hardwareMap);
        telemetry.addData("Status", "Initialized");
        telemetry.update();
        leftFrontDrive = hardwareMap.get(DcMotor.class, "leftFrontMotor");  // motor 2
        rightFrontDrive = hardwareMap.get(DcMotor.class, "rightFrontMotor"); // motor 3
        leftBackDrive = hardwareMap.get(DcMotor.class, "leftBackMotor"); // motor 0
        rightBackDrive = hardwareMap.get(DcMotor.class, "rightBackMotor"); // motor 1
        armMotor = hardwareMap.get(DcMotor.class, "armMotor");
        launchMotor = hardwareMap.get(DcMotorEx.class, "launchMotor");
        wobblerServo = hardwareMap.get(Servo.class, "wobblerServo");
        launchServo = hardwareMap.get(Servo.class, "launchServo");
        intakeMotor = hardwareMap.get(DcMotor.class, "intakeMotor");

        // Wait for game to start (driver presses PLAY
        waitForStart();

        // run until driver presses STOP
        while (opModeIsActive())
        //while (opModeIsActive() && (runtime.seconds() < 31.0))
        {
            //testWheelServo();
            driveWithTwoJoysticks();
            driveArm();
            driveLauncher();
            pushRings();
            grabWobbler();
            intakeMotor();
        }
    }


    // drive with joysticks
    public void driveWithTwoJoysticks() {
        double max;
        // Run wheels in POV mode (note: The joystick goes negative when pushed forwards, so negate it)
        // In this mode the Left stick moves the robot fwd and back and crabs left and right,
        // the Right stick tank turns left and right
        double speedLF = -(gamepad1.left_stick_y + gamepad1.left_stick_x - gamepad1.right_stick_x);
        double speedLB = -(gamepad1.left_stick_y - gamepad1.left_stick_x - gamepad1.right_stick_x);
        double speedRF = -(gamepad1.left_stick_y - gamepad1.left_stick_x + gamepad1.right_stick_x);
        double speedRB = -(gamepad1.left_stick_y + gamepad1.left_stick_x + gamepad1.right_stick_x);


        // Clip values so that they are within -1 & +1
        speedLF = Range.clip(speedLF, -1, 1);
        speedLB = Range.clip(speedLB, -1, 1);
        speedRF = Range.clip(speedRF, -1, 1);
        speedRB = Range.clip(speedRB, -1, 1);

        // Set speed to motors
        //leftfront = 0
        //rightfront = 1
        //leftback = 2
        //rightback = 3
        robot.leftFrontDrive.setPower(p[0] * speedLF);
        robot.leftBackDrive.setPower(speedLB);
        robot.rightFrontDrive.setPower(p[1] * speedRF);
        robot.rightBackDrive.setPower(speedRB);
    }

    public void driveArm() {
        if (gamepad2.dpad_down) {
            robot.armMotor.setPower(-0.5);
        }
        if (gamepad2.dpad_right) {
            robot.armMotor.setPower(0.05);
        }
        if (gamepad2.dpad_up) {
            robot.armMotor.setPower(0.5);
        }
    }
    public void driveLauncher() {
        if (gamepad2.a){
            robot.launchMotor.setVelocity(-2700);
        }
        if (gamepad2.b){
            robot.launchMotor.setVelocity(0);

        }
        if (gamepad2.dpad_left) {
            robot.launchMotor.setVelocity(-10000);

        }
        if (gamepad1.dpad_up) {
            encoderTurn(0.2, -1, 40, 40);
            sleep(50);
            robot.launchMotor.setVelocity(-2200);
            robot.intakeMotor.setPower(-0.9);
            sleep(1000);
            robot.launchServo.setPosition(0.45);
            sleep(250);
            robot.launchServo.setPosition(-0.5);
            sleep(200);
            robot.launchServo.setPosition(0.45);
            sleep(200);
            encoderTurn(0.4, -1, 65, 65);
            sleep(500);
            robot.launchServo.setPosition(-0.5);
            sleep(200);
            robot.launchServo.setPosition(0.45);
            sleep(200);
            encoderTurn(0.4, -1, 85, 85);
            sleep(800);
            robot.launchServo.setPosition(-0.5);
            sleep(200);
            robot.launchServo.setPosition(0.45);
            sleep(200);

            robot.launchMotor.setVelocity(0);
           robot.intakeMotor.setPower(0);
        }
        if (gamepad1.dpad_left) {
            robot.launchMotor.setVelocity(-2250);
            sleep(1000);
            robot.launchServo.setPosition(0.45);
            sleep(250);
            robot.launchServo.setPosition(-0.5);
            sleep(50);
        }
    }
    public void pushRings() throws InterruptedException {
        if (gamepad2.left_bumper){
            robot.launchServo.setPosition(-0.5);
            sleep(200);
            robot.launchServo.setPosition(0.45);
            sleep(30);
        }
        if (gamepad2.right_bumper){
            int x = 0;
            for(x = 0; x < 3; x++){
                robot.launchServo.setPosition(-0.5);
                sleep(200);
                robot.launchServo.setPosition(0.45);
                sleep(200);
            }

        }

    }

    public void grabWobbler() {
        if (gamepad2.x){
            robot.wobblerServo.setPosition(0.7);
        }
        if (gamepad2.y){
            robot.wobblerServo.setPosition(0.2);
        }
    }
    public void intakeMotor() {
        if (gamepad1.right_bumper){
            robot.intakeMotor.setPower(1);
        }
        if (gamepad1.left_bumper){
            robot.intakeMotor.setPower(0);
        }
        if (gamepad1.x) {
            robot.intakeMotor.setPower(-0.9);
        }


    }
    private void encoderTurn(double speed, int direction, int leftTicks, int rightTicks) {
        stopAndResetEncoder();
        runUsingEncoder();

        if (opModeIsActive()) {
            int leftF = leftFrontDrive.getCurrentPosition() + leftTicks;
            int leftB = leftBackDrive.getCurrentPosition() + leftTicks;
            int rightF = rightFrontDrive.getCurrentPosition() + rightTicks;
            int rightB = rightBackDrive.getCurrentPosition() + rightTicks;

            //if intent is left turn
            if (direction == -1) {
                leftFrontDrive.setTargetPosition(leftF);
                leftBackDrive.setTargetPosition(leftB);
                rightFrontDrive.setTargetPosition(-rightF);
                rightBackDrive.setTargetPosition(-rightB);
            }
            //if intent is right turn
            else if (direction == 1) {
                leftFrontDrive.setTargetPosition(-leftF);
                leftBackDrive.setTargetPosition(-leftB);
                rightFrontDrive.setTargetPosition(rightF);
                rightBackDrive.setTargetPosition(rightB);
            }

            runToPosition();

            if (direction == -1) {
                leftFrontDrive.setPower(speed);
                leftBackDrive.setPower(speed);
                rightFrontDrive.setPower(speed);
                rightBackDrive.setPower(speed);
            } if (direction == 1) {
                leftFrontDrive.setPower(speed);
                leftBackDrive.setPower(speed);
                rightFrontDrive.setPower(speed);
                rightBackDrive.setPower(speed);
            }

            while (opModeIsActive() &&
                    //           (runtime.seconds() < timeout) &&
                    (leftFrontDrive.isBusy() && rightFrontDrive.isBusy() &&
                            leftBackDrive.isBusy() && rightBackDrive.isBusy()
                    )
                    && leftFrontDrive.getCurrentPosition() < leftTicks) {

                // Display it for the driver.
//                telemetry.addData("LFT, RFT", "Running to %7d :%7d", leftF, rightF);
//                telemetry.addData("LFP, RFP", "Running at %7d :%7d",
//                        robot.leftFrontDrive.getCurrentPosition(),
//                        robot.rightFrontDrive.getCurrentPosition());
//
//                telemetry.addData("LBT. RBT", "Running to %7d :%7d", leftB, rightB);
//                telemetry.addData("LBP, RBP", "Running at %7d :%7d",
//                        robot.leftBackDrive.getCurrentPosition(),
//                        robot.rightBackDrive.getCurrentPosition());
                // telemetry.update();
            }

            stopDriveBase();
        }
    }
    private void runToPosition () {
        leftFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightFrontDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        leftBackDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightBackDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);

    }
    private void stopDriveBase(){
        leftFrontDrive.setPower(0);
        rightFrontDrive.setPower(0);
        leftBackDrive.setPower(0);
        rightBackDrive.setPower(0);
    }
    private void stopAndResetEncoder() {
        leftFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightFrontDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftBackDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rightBackDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    }
    private void runUsingEncoder() {
        leftFrontDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rightFrontDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        leftBackDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rightBackDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }
//    public void testWheelServo () {
//        if (gamepad1.a)
//        {
//            robot.leftServo.setPosition(1);
//            robot.rightServo.setPosition(-1);
//        }
//        if (gamepad1.b)
//        {
//            robot.leftServo.setPosition(-1);
//            robot.rightServo.setPosition(1);
//        }
}

